/* context-free expression grammar */

program         -> (declaration NEWLINE*? )* EOF ;

declaration     -> var_declaration
                |  statement ;

statement       -> expr_stmt
                |  loop_stmt
                |  assert_stmt
                |  if_stmt
                |  cmd_stmt
                |  assignment_stmt
                |  block ;

var_declaration -> "var" IDENTIFIER "=" expression NEWLINE ;


/* statements */

/* 
 * if optional ( IDENTIFIER "in" ) is present then the following expression must be iterable.
 * if not, then a runtime error will raise
 */
loop_stmt       -> "loop" ( IDENTIFIER "in" )? expression block ;

assert_stmt     -> "assert" expression ;

if_stmt         -> "if" expression block (( "elif" expression block ) | ( "else" block ))? ;

cmd_stmt        -> SHIDENT ( argument* )? ;

pipeline_stmt   -> cmd_stmt "|" pipeline_stmt ;

assignment_stmt -> access ("=" | "+=" | "-=") expression ;

expr_stmt       -> expressions NEWLINE ;

block           -> "{" statement* "}" ;


/* expressions */

//TODO: currently just a linked list, should be its own expr?
comma_sep_exprs -> (argument ",")*? ;

argument        -> expression ;

expression      -> equality ;

equality        -> comparison (( "!=" | "==" ) comparison )* ;
comparison      -> term (( ">" | ">=" | "<" | "<=" ) term )* ;
term            -> factor (( "-" | "+" ) factor )* ;
factor          -> unary ;
unary           -> method_call
                |  contains
                |  subshell
                |  item_access ;

method_call     -> expression "." IDENTIFIER "(" comma_sep_exprs ")" ;

contains        -> expression "in" expression ;

subshell        -> "(" cmd_stmt ")" ;
                |  "(" pipeline_stmt ")" ;

item_access     -> ACCESS "[" expression "]"
                |  access ;

access          -> ACCESS
                |  primary ;

primary         -> STRING 
                |  SHIDENT
                |  bool_lit
                |  number
                |  range 
                |  list
                |  map
                |  tuple ;

bool_lit        -> "true" | "false ";

number          -> NUMBER ;

range           -> NUMBER? ".." NUMBER ;

list            -> "[" comma_sep_exprs "]" ;

map             -> "@[" ( expression ":" expression "," )*? "]"

tuple           -> "'" comma_sep_exprs "'" ;
