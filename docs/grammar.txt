/* context-free expression grammar */

Each rule is a name followed by an arrow, followed by a sequence of of symbols ending with a semicolon.
Terminals are qouted strings or uppercase words.
Non-terminals are lowercase words.
'|' symbol seperates series of productions for a given rule.
() grouping
* repeat zero or more times
+ repeat one or more times
? optional




program         -> ( declaration newline )* EOF ;

newline         -> ( "\n" | ";" )+ ;

declaration     -> var_declaration
                |  statement ;

statement       -> expr_stmt
                |  loop_stmt
                |  assert_stmt
                |  if_stmt
                |  assignment_stmt
                |  pipeline_stmt
                |  block ;

var_declaration -> "var" IDENTIFIER "=" expression newline ;


/* statements */

loop_stmt       -> "loop" ( IDENTIFIER "in" )? expression block ;

assert_stmt     -> "assert" expression ;

if_stmt         -> "if" expression block ( ( "elif" expression block ) | ( "else" block ) )? ;

assignment_stmt -> access ( "=" | "+=" | "-=" ) expression ;

expr_stmt       -> expression newline ;

pipeline_stmt   -> cmd_stmt ( "|" pipeline_stmt )* ;

cmd_stmt        -> SHIDENT argument* ;

block           -> "{" declaration* "}" ;



/* expressions */

//TODO: currently just a linked list, should be its own expr?
sequence_expr   -> ( argument "," )* ;

argument        -> expression ;

expression      -> logic_or ;

logic_or        -> logic_and ( "or" logic_and )* ;
logic_and       -> equality ( "and" equality )* ;

equality        -> comparison ( ( "!=" | "==" ) comparison )* ;

comparison      -> term ( ( ">" | ">=" | "<" | "<=" ) term )* ;

term            -> factor ( ( "-" | "+" ) factor )* ;

factor          -> unary ;

unary           -> method_call
                |  contains
                |  subshell
                |  item_access ;

method_call     -> expression "." IDENTIFIER "(" sequence_expr ")" ;

contains        -> expression "in" expression ;

subshell        -> "(" declaration+ ")" ;

item_access     -> ACCESS "[" expression "]"
                |  access ;

access          -> ACCESS
                |  primary ;

primary         -> STRING 
                |  bool_lit
                |  number
                |  range 
                |  list
                |  map
                |  tuple 
                | "(" expression ")" ;

bool_lit        -> "true" | "false ";

number          -> NUMBER ;

range           -> expression? ".." expression ;

list            -> "[" sequence_expr "]" ;

map             -> "@[" ( expression ":" expression "," )* "]"

tuple           -> "'" sequence_expr "'" ;
