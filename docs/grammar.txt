/* context-free expression grammar */

Each rule is a name followed by an arrow, followed by a sequence of of symbols ending with a semicolon.
Terminals are qouted strings or uppercase words.
Non-terminals are lowercase words.
'|' symbol seperates series of productions for a given rule.
() grouping
* repeat zero or more times
+ repeat one or more times
? optional



program         -> declaration* EOF ;

newline         -> ( "\n" | ";" )+ ;

expr_promotion  -> newline | "}" | "&&" | "||" ;

declaration     -> var_declaration
                |  and_or ;

var_declaration -> "var" IDENTIFIER "=" expression newline ;

and_or          -> statement ( ( "&&" | "||" ) statement )* ;


/* statements */

statement       -> loop_stmt
                |  assert_stmt
                |  if_stmt
                |  pipeline_stmt
                |  block
                |  assignment_stmt
                |  expr_stmt ;

loop_stmt       -> "loop" ( IDENTIFIER "in" )? expression block ;

assert_stmt     -> "assert" expression newline_or_block_end ;

if_stmt         -> "if" expression block ( ( "elif" expression block ) | ( "else" block ) )? ;

pipeline_stmt   -> cmd_stmt ( "|" pipeline_stmt )* ;

cmd_stmt        -> SHIDENT argument* ;

block           -> "{" declaration* "}" ;

assignment_stmt -> subscript ( "=" | "+=" | "-=" ) expression newline_or_block_end ;

expr_stmt       -> expression newline_or_block_end ;



/* expressions */

sequence_expr   -> ( argument ( "," argument )* )? ;

argument        -> expression ;

expression      -> logical_or ;

logical_or      -> logical_and ( "or" logical_and )* ;

logical_and     -> equality ( "and" equality )* ;

equality        -> comparison ( ( "!=" | "==" ) comparison )* ;

comparison      -> term ( ( ">" | ">=" | "<" | "<=" ) term )* ;

term            -> factor ( ( "-" | "+" ) factor )* ;

factor          -> unary ;

unary           -> subshell
                |  method_call
                |  contains
                |  cast
                |  subscript ;

subshell        -> "(" declaration+ ")" ;

method_call     -> expression "." IDENTIFIER "(" sequence_expr ")" ;

contains        -> expression "in" expression ;

cast            -> expression "as" TYPE ;

subscript       -> access ( "[" expression "]" )? ;

subscript       -> access ( "[" expression "]" )? ;

access          -> ACCESS | primary ;

primary         -> STRING 
                |  bool_lit
                |  number
                |  range 
                |  list
                |  map
                |  tuple 
                |  grouping ;

bool_lit        -> "true" | "false ";

number          -> NUMBER ;

range           -> expression? ".." expression ;

list            -> "[" sequence_expr "]" ;

map             -> "@[" ( expression ":" expression "," )* "]"

tuple           -> "'" sequence_expr "'" ;

grouping        -> "(" expression ")" ;
